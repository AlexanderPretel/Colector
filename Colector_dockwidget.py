# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ColectorGPSDockWidget
                                 A QGIS plugin
 Complemento que permite la recolección de información espacial y alfanumérica en QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-03-04
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Alexander Pretel Díaz
        email                : alexander.pretel@correounivalle.edu.co
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Importar librerías necesarias
import os
import subprocess
import threading
from qgis.utils import *
from qgis.core import *
from qgis.gui import *
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from datetime import datetime
import time
import concurrent.futures

#Importa la interfaz gráfica de la aplicación y permite acceder a los objetos que la controlan y que pueden interactuar con el usuario
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Colector_dockwidget_base.ui'))


class ColectorGPSDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    #Función de inicio quien tiene la función de ser el constructor del programa, sus objetos y variables
    def __init__(self, parent=None):
        """Constructor."""
        #Elementos que alimentan la interfaz y declaración de variables globales
        self.iface = iface
        self.tools = self.iface.vectorLayerTools()
        self.prj = QgsProject().instance()
        super(ColectorGPSDockWidget, self).__init__(parent)
        self.setupUi(self)
        self.src_crs = QgsCoordinateReferenceSystem("EPSG:4326")
        self.prj.setCrs(self.src_crs)
        self.dest_crs = self.prj.crs()
        self.transformation = QgsCoordinateTransform(self.src_crs, self.dest_crs, self.prj)
        self.marker = None
        self.marker_polyline = None
        self.marker_polygon = None
        self.gpsCon = None
        self.detector = None
        self.gps_active = False
        self.colectar = False
        self.listaCoordenadas = None
        self.vertice = False
        self.field_combo_box = QgsFieldComboBox()
        self.canvas = self.iface.mapCanvas()
        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.openProject = False
        self.homeFolder = str(os.getcwd())
        self.nameProject = None
        self.pathProject = None
        self.folder = datetime.now().strftime('%d_%m_%y')
        self.pathFolder = None
        if not os.path.exists("{0}/Proyectos/".format(str(self.homeFolder))):
            os.mkdir("{0}/Proyectos/".format(str(self.homeFolder)))
        self.tiempoCaptura = 5 #Por defecto el tiempo de captura se establece en 5 segundos. Pero el usuario lo puede cambiar
        self.btnubicar.clicked.connect(self.locate)
        self.mMapLayerComboBox.layerChanged.connect(self.field_combo_box.setLayer)
        self.btnubicarycentrar.clicked.connect(self.collect)
        self.btnaddVertice.clicked.connect(self.add_new_vertex)
        self.btnendGeometry.clicked.connect(self.create_geometry_polygon_or_line)
        self.crearProyecto.clicked.connect(self.newProject)
        self.cargarProyecto.clicked.connect(self.existProject)
        self.btnImportarCapas.clicked.connect(self.importCapas)

    def newProject(self):
        self.pathProject = QtWidgets.QFileDialog.getExistingDirectory(None, 'Crear proyecto', str(self.homeFolder) + "/Proyectos/")
        if not self.pathProject == '':
            self.tiempoCaptura = self.tiempoColeccion.currentText()
            self.openProject = True
            self.enableProject()
            self.folder = datetime.now().strftime('%d_%m_%y')
            if not os.path.exists("{0}/Base/".format(self.pathProject)):
                os.mkdir("{0}/Base/".format(self.pathProject))
            if not os.path.exists("{0}/Export/".format(self.pathProject)):
                os.mkdir("{0}/Export/".format(self.pathProject))
            if not os.path.exists("{0}/Survey/".format(self.pathProject)):
                os.mkdir("{0}/Survey/".format(self.pathProject))
            self.pathFolder = "{0}/Survey/{1}/".format(self.pathProject, str(self.folder))
            if not os.path.exists(self.pathFolder):
                os.mkdir(self.pathFolder)
            qgzProject = "{0}/Qgs.qgz".format(self.pathProject)
            self.prj.write(qgzProject)
            self.prj.setTitle(str(self.pathProject))
        else:
            self.iface.messageBar().pushMessage(u'Colector Infomra', u'No se ha podido crear el proyecto',
                                                level=Qgis.Critical)

    def existProject(self):
        self.pathProject = QtWidgets.QFileDialog.getExistingDirectory(None, 'Abrir proyecto', str(self.homeFolder) + "/Proyectos/")
        if not self.pathProject == '':
            self.prj.read("{0}/Qgs.qgz".format(self.pathProject))
            self.openProject = True
            self.enableProject()
            if not os.path.exists("{0}/Base/".format(self.pathProject)):
                os.mkdir("{0}/Base/".format(self.pathProject))
            if not os.path.exists("{0}/Export/".format(self.pathProject)):
                os.mkdir("{0}/Export/".format(self.pathProject))
            if not os.path.exists("{0}/Survey/".format(self.pathProject)):
                os.mkdir("{0}/Survey/".format(self.pathProject))
            self.folder = datetime.now().strftime('%d_%m_%y')
            self.pathFolder = "{0}/Survey/{1}/".format(self.pathProject, str(self.folder))
            print(self.pathFolder)
            if not os.path.exists(self.pathFolder):
                os.mkdir(self.pathFolder)
            self.prj.setTitle(str(self.pathProject))
        else:
            self.iface.messageBar().pushMessage(u'Colector Infomra',
                                                u'Hubo un problema con el proyecto. Vuelve a importarlo o crea uno nuevo',
                                                level=Qgis.Critical)

    def importCapas(self):
        dirBase = "{0}/Base/".format(self.pathProject)
        if os.path.exists(dirBase):
            listDir = os.walk(dirBase)
            for root, dirs, files in listDir:
                for fichero in files:
                    (nombre, extension) = os.path.splitext(fichero)
                    if extension == ".shp":
                        layer = QgsVectorLayer(root+nombre+extension, nombre, "ogr")
                        if not layer.isValid():
                            print("Layer failed to load!")
                        else:
                            self.prj.addMapLayer(layer)
                    elif extension == ".tiff" or extension == ".tif" or extension == ".TIF" or extension == ".TIFF" or extension == ".ecw" or extension == ".mbtiles":
                        layer = QgsRasterLayer(root+nombre+extension, nombre)
                        if not layer.isValid():
                            print("Layer failed to load!")
                        else:
                            self.prj.addMapLayer(layer)

    def enableProject(self):
        if self.openProject:
            self.tabWidgetPage2.setEnabled(True)
            self.tiempoColeccion.setEnabled(True)
            self.btnImportarCapas.setEnabled(True)
        else:
            self.tabWidgetPage2.setEnabled(False)
            self.tiempoColeccion.setEnabled(False)
            self.btnImportarCapas.setEnabled(False)

    def locate(self):
        try:
            if self.btnubicar.text() == "Ubicar":
                self.btnubicar.setText("Desconectar")
                print('GPS ubicar')
                if self.marker is not None:
                    self.canvas.scene().removeItem(self.marker)
                self.detector = QgsGpsDetector("/dev/ttyACM0")
                # print(self.detector)
                self.detector.detected[QgsGpsConnection].connect(self.connection_succeed)
                self.detector.detectionFailed.connect(self.connection_failed)
                self.detector.advance()
            elif self.btnubicar.text() == "Desconectar":
                self.deactivate()

        except Exception as e:
            print(e)

    def deactivate(self):
        try:
            print('GPS deactivated')
            if self.gpsCon is not None:
                self.gpsCon.close()
                self.btnubicar.setText("Ubicar")
            if self.canvas is not None:
                self.marker.setColor(QColor(0, 0, 255))
            #    self.canvas.scene().removeItem(self.marker)
            self.gps_active = False
        except Exception as e:
            print(e)

    def connection_succeed(self, connection):
        try:
            print("GPS connected")
            self.gps_active = True
            self.gpsCon = connection
            self.prj.setCrs(self.src_crs)
            if not self.colectar and not self.vertice:
                self.gpsCon.stateChanged.connect(self.status_changed)
            elif self.colectar and not self.vertice:
                self.gpsCon.stateChanged.connect(self.create_geometry)
            elif self.vertice:
                self.gpsCon.stateChanged.connect(self.create_vertex)
            # marker
            self.marker = QgsVertexMarker(self.canvas)
            self.marker.setColor(QColor(255, 0, 0))  # (R,G,B)
            self.marker.setIconSize(10)
            self.marker.setIconType(QgsVertexMarker.ICON_CIRCLE)
            self.marker.setPenWidth(3)
        except Exception as e:
            print(e)

    def status_changed(self, gpsInfo):
        try:
            if gpsInfo.latitude != 0 and gpsInfo.longitude != 0:
                wgs84_pointXY = QgsPointXY(gpsInfo.longitude, gpsInfo.latitude)
                wgs84_point = QgsPoint(wgs84_pointXY)
                wgs84_point.transform(self.transformation)
                mapPointXY = QgsPointXY(wgs84_point.x(), wgs84_point.y())
                if gpsInfo.pdop >= 1:  # gps ok
                    self.marker.setColor(QColor(0, 200, 0))
                else:
                    self.marker.setColor(QColor(255, 0, 0))
                self.marker.setCenter(mapPointXY)
                self.marker.show()
                self.canvas.refresh()
                self.canvas.setCenter(mapPointXY)
        except Exception as e:
            print(e)

    def create_geometry(self, gpsInfo):
        try:
            if self.colectar and gpsInfo.isValid():
                if gpsInfo.latitude != 0 and gpsInfo.longitude != 0:
                    self.status_changed(gpsInfo)
                    layer = self.field_combo_box.layer()
                    self.tiempoCaptura = self.tiempoColeccion.currentText()
                    self.prj.setCrs(self.src_crs)
                    if layer.geometryType() == QgsWkbTypes.PointGeometry:
                        print("colectar punto: lat ", gpsInfo.latitude, " lon ", gpsInfo.longitude)
                        self.colectar = False
                        field_idx = layer.fields().indexOf('id')
                        layer.startEditing()
                        if field_idx == -1:
                            layer.addAttribute(QgsField('id', QVariant.Int))
                            field_idx = layer.fields().indexOf('id')
                        if layer.featureCount() == 0:
                            idActual = 1
                        elif layer.featureCount() > 0:
                            idActual = int(max([num[field_idx] for num in layer.getFeatures()])) + 1
                        config = layer.editFormConfig()
                        if not config.readOnly(field_idx):
                            config.setReadOnly(field_idx, True)
                            layer.setEditFormConfig(config)
                        feature = QgsFeature(layer.fields())
                        feature.setAttribute(field_idx, idActual)
                        feature.setGeometry(QgsPoint(gpsInfo.longitude, gpsInfo.latitude))
                        self.deactivate()
                        form = QgsAttributeDialog(layer, feature, False)
                        form.setMode(QgsAttributeEditorContext.AddFeatureMode)

                        result = form.exec_()
                        if result == 1:
                            atributos = form.feature().attributes()
                            future = concurrent.futures.ThreadPoolExecutor().submit(self.collect_ubx, layer, idActual)
                            #thread = threading.Thread(target=self.collect_ubx, args=(layer, idActual))
                            #thread.start()
                            progressMessageBar = self.iface.messageBar().createMessage("Colectando ubx...")
                            progress = QProgressBar()
                            progress.setMaximum(int(self.tiempoCaptura)+1)
                            progressMessageBar.layout().addWidget(progress)
                            self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                            for i in range(int(self.tiempoCaptura)+1):
                                time.sleep(1)
                                progress.setValue(i + 1)
                            self.iface.messageBar().clearWidgets()
                            if future.result() == 0:
                                #print(future.result())
                                self.iface.messageBar().pushInfo(u'Colector Infomra',
                                                                 u'Punto agregado en {0}'.format(str(layer.name())))
                                self.create_txt_with_features(layer, attr=atributos)
                            layer.updateExtents()
                            self.tools.saveEdits(layer)
                            self.prj.addMapLayer(layer)
                            self.tools.stopEditing(layer, False)
                            self.canvas.refresh()
                        elif result == 0:
                            self.iface.messageBar().pushMessage(u'Colector Infomra', u'No se pudo colectar el punto',
                                                                level=Qgis.Warning)
                            self.tools.stopEditing(layer, False)
                    elif layer.geometryType() == QgsWkbTypes.LineGeometry or layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                        self.tableVertices.clearContents()
                        #print(self.listaCoordenadas)
                        self.listaCoordenadas = []
                        #print(self.listaCoordenadas)
                        self.colectar = False
                        self.mMapLayerComboBox.setEnabled(False)
                        self.tableVertices.setEnabled(True)
                        self.btnaddVertice.setEnabled(True)
                        self.btnubicarycentrar.setText("Cancelar")
                        id = len(self.listaCoordenadas) + 1
                        self.listaCoordenadas.append([id, gpsInfo.latitude, gpsInfo.longitude, gpsInfo.elevation])
                        print(self.listaCoordenadas)
                        rowPosition = self.tableVertices.rowCount()
                        self.tableVertices.setRowCount(rowPosition + 1)
                        self.tableVertices.setItem(rowPosition, 0, QTableWidgetItem(str(id)))
                        self.tableVertices.setItem(rowPosition, 1, QTableWidgetItem(str(gpsInfo.latitude)))
                        self.tableVertices.setItem(rowPosition, 2, QTableWidgetItem(str(gpsInfo.longitude)))
                        self.tableVertices.setItem(rowPosition, 3, QTableWidgetItem(str(gpsInfo.elevation)))
                        self.deactivate()
                        field_idx = layer.fields().indexOf('id')
                        layer.startEditing()
                        if field_idx == -1:
                            layer.addAttribute(QgsField('id', QVariant.Int))
                            field_idx = layer.fields().indexOf('id')
                        if layer.featureCount() == 0:
                            idActual = 1
                        elif layer.featureCount() > 0:
                            idActual = int(max([num[field_idx] for num in layer.getFeatures()])) + 1
                        future = concurrent.futures.ThreadPoolExecutor().submit(self.collect_ubx, layer, idActual, id)
                        progressMessageBar = self.iface.messageBar().createMessage("Colectando ubx...")
                        progress = QProgressBar()
                        progress.setMaximum(int(self.tiempoCaptura) + 1)
                        progressMessageBar.layout().addWidget(progress)
                        self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                        for i in range(int(self.tiempoCaptura) + 1):
                            time.sleep(1)
                            progress.setValue(i + 1)
                        self.iface.messageBar().clearWidgets()
                        if future.result() == 0:
                            self.iface.messageBar().pushInfo(u'Colector Infomra', u'Vértice agregado')
                        layer.updateExtents()
                        self.tools.saveEdits(layer)
                        self.prj.addMapLayer(layer)
                        self.tools.stopEditing(layer, False)
                        self.canvas.refresh()
            elif not self.colectar:
                self.deactivate()
        except ValueError as e:
            self.deactivate()
            print(e)

    def create_geometry_polygon_or_line(self):
        layer = self.field_combo_box.layer()
        if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
            points = []
            layer.startEditing()
            for iterador in self.listaCoordenadas:
                if iterador[2] != 0 and iterador[1] != 0:
                    points.append(QgsPointXY(iterador[2], iterador[1]))
            field_idx = layer.fields().indexOf('id')
            if field_idx == -1:
                layer.addAttribute(QgsField('id', QVariant.Int))
                field_idx = layer.fields().indexOf('id')
            if layer.featureCount() == 0:
                idActual = 1
            elif layer.featureCount() > 0:
                idActual = int(max([num[field_idx] for num in layer.getFeatures()])) + 1
            config = layer.editFormConfig()
            if config.readOnly(field_idx):
                config.setReadOnly(field_idx, True)
                layer.setEditFormConfig(config)
            feature = QgsFeature(layer.fields())
            feature.setGeometry(QgsGeometry.fromPolygonXY([points]))
            feature.setAttribute(field_idx, idActual)
            form = QgsAttributeDialog(layer, feature, False)
            form.setMode(QgsAttributeEditorContext.AddFeatureMode)
            result = form.exec_()
            if result == 1:
                atributos = form.feature().attributes()
                self.iface.messageBar().pushInfo(u'Colector Infomra', u'Poligono agregado correctamente')
            elif result == 0:
                self.iface.messageBar().pushMessage(u'Colector Infomra', u'No se pudo colectar el Poligono',
                                                    level=Qgis.Warning)
            layer.updateExtents()
            self.tools.saveEdits(layer)
            self.prj.addMapLayer(layer)
            self.tools.stopEditing(layer, False)
            self.canvas.refresh()
            self.canvas.scene().removeItem(self.marker_polygon)
            print("El polígono se compone por los siguientes vértices ", self.listaCoordenadas)
        elif layer.geometryType() == QgsWkbTypes.LineGeometry:
            points = []
            layer.startEditing()
            for iterador in self.listaCoordenadas:
                if iterador[2] != 0 and iterador[1] != 0:
                    points.append(QgsPoint(iterador[2], iterador[1]))
            field_idx = layer.fields().indexOf('id')
            if field_idx == -1:
                layer.addAttribute(QgsField('id', QVariant.Int))
                field_idx = layer.fields().indexOf('id')
            if layer.featureCount() == 0:
                idActual = 1
            elif layer.featureCount() > 0:
                idActual = int(max([num[field_idx] for num in layer.getFeatures()])) + 1
            config = layer.editFormConfig()
            if not config.readOnly(field_idx):
                config.setReadOnly(field_idx, True)
                layer.setEditFormConfig(config)
            feature = QgsFeature(layer.fields())
            feature.setGeometry(QgsGeometry.fromPolyline(points))
            print(field_idx)
            feature.setAttribute(field_idx, idActual)
            form = QgsAttributeDialog(layer, feature, False)
            form.setMode(QgsAttributeEditorContext.AddFeatureMode)
            result = form.exec_()
            if result == 1:
                atributos = form.feature().attributes()
                self.iface.messageBar().pushInfo(u'Colector Infomra', u'Línea agregada correctamente')
            elif result == 0:
                self.iface.messageBar().pushMessage(u'Colector Infomra', u'No se pudo colectar la Línea',
                                                    level=Qgis.Warning)
            layer.updateExtents()
            self.tools.saveEdits(layer)
            self.prj.addMapLayer(layer)
            self.tools.stopEditing(layer, False)
            self.canvas.refresh()
            self.canvas.scene().removeItem(self.marker_polyline)
            print("La línea se compone por los siguientes vértices ", self.listaCoordenadas)
        self.create_txt_with_features(layer, attr=atributos)
        self.tableVertices.clearContents()
        self.tableVertices.setRowCount(0)
        self.btnaddVertice.setEnabled(False)
        self.btnendGeometry.setEnabled(False)
        self.tableVertices.setEnabled(False)
        self.mMapLayerComboBox.setEnabled(True)
        self.btnubicarycentrar.setText("Colectar")

    def create_vertex(self, gpsInfo):
        if self.vertice and gpsInfo.isValid():
            if gpsInfo.latitude != 0 and gpsInfo.longitude != 0:
                self.tiempoCaptura = self.tiempoColeccion.currentText()
                print("create vertex")
                self.status_changed(gpsInfo)
                id = len(self.listaCoordenadas) + 1
                self.listaCoordenadas.append([id, gpsInfo.latitude, gpsInfo.longitude, gpsInfo.elevation])
                rowPosition = self.tableVertices.rowCount()
                self.tableVertices.setRowCount(rowPosition + 1)
                self.tableVertices.setItem(rowPosition, 0, QTableWidgetItem(str(id)))
                self.tableVertices.setItem(rowPosition, 1, QTableWidgetItem(str(gpsInfo.latitude)))
                self.tableVertices.setItem(rowPosition, 2, QTableWidgetItem(str(gpsInfo.longitude)))
                self.tableVertices.setItem(rowPosition, 3, QTableWidgetItem(str(gpsInfo.elevation)))
                self.btnendGeometry.setEnabled(True)
                self.vertice = False
                if self.field_combo_box.layer().featureCount() == 0:
                    idActual = 1
                elif self.field_combo_box.layer().featureCount() > 0:
                    idActual = int(max([num[0] for num in self.field_combo_box.layer().getFeatures()])) + 1
                if self.field_combo_box.layer().geometryType() == QgsWkbTypes.LineGeometry:
                    if self.marker_polyline is None:
                        print(self.marker_polyline)
                        self.marker_polyline = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
                        print(self.marker_polyline)
                        self.marker_polyline.addPoint(
                            QgsPointXY(self.listaCoordenadas[0][2], self.listaCoordenadas[0][1]))
                        self.marker_polyline.setColor(QColor(0, 0, 255, 80))
                        self.marker_polyline.setWidth(5)
                        self.marker_polyline.show()
                        # self.canvas.scene().removeItem(self.marker_polyline)
                    self.marker_polyline.addPoint(QgsPointXY(gpsInfo.longitude, gpsInfo.latitude))
                elif self.field_combo_box.layer().geometryType() == QgsWkbTypes.PolygonGeometry:
                    if self.marker_polygon is None:
                        print(QColor(0, 0, 255, 127))
                        self.marker_polygon = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
                        print(self.marker_polygon)
                        self.marker_polygon.addPoint(
                            QgsPointXY(self.listaCoordenadas[0][2], self.listaCoordenadas[0][1]))
                        self.marker_polygon.setColor(QColor(0, 0, 255, 80))
                        self.marker_polygon.setWidth(2)
                        self.marker_polygon.show()
                        # self.canvas.scene().removeItem(self.marker_polygon)
                    self.marker_polygon.addPoint(QgsPointXY(gpsInfo.longitude, gpsInfo.latitude))
                self.deactivate()
                future = concurrent.futures.ThreadPoolExecutor().submit(self.collect_ubx, self.field_combo_box.layer(), idActual, id)
                progressMessageBar = self.iface.messageBar().createMessage("Colectando ubx...")
                progress = QProgressBar()
                progress.setMaximum(int(self.tiempoCaptura) + 1)
                progressMessageBar.layout().addWidget(progress)
                self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                for i in range(int(self.tiempoCaptura) + 1):
                    time.sleep(1)
                    progress.setValue(i + 1)
                self.iface.messageBar().clearWidgets()
                if future.result() == 0:
                    self.iface.messageBar().pushInfo(u'Colector Infomra', u'Vértice agregado')
        elif not self.vertice:
            self.deactivate()

    def connection_failed(self):
        if not self.gps_active:
            print('GPS connection failed')
            self.iface.messageBar().pushMessage(u'Colector Infomra', u'No ha sido posible conectar con el receptor',
                                                level=Qgis.Critical)
            self.deactivate()

    def collect(self):
        if self.field_combo_box.layer() is not None:
            if self.btnubicarycentrar.text() == "Cancelar":
                self.cancell()
            else:
                self.colectar = True
                self.locate()
        else:
            self.iface.messageBar().pushMessage("Error", "Debe cargar una capa vectorial al proyecto", Qgis.Critical)

    def create_txt_with_features(self, layer: QgsVectorLayer, attr):
        #archivoTxt = self.pathFolder + layer.name() + "/" + layer.name() +".txt"
        archivoTxt = "{0}{1}/{1}.txt".format(str(self.pathFolder), str(layer.name()))
        fields = layer.fields()
        if not os.path.exists(archivoTxt):
            file = open(archivoTxt, "w")
            #file.write(str(layer.fields().names()).replace('[', '').replace(']', '').replace(' ', '') + os.linesep)
        else:
            file = open(archivoTxt, "a")
        lista = []
        for iterador in range(len(attr)):
            field = fields[iterador]
            nombreField = field.name()
            type = field.typeName()
            atributo = attr[iterador]
            lista.append(nombreField)
            lista.append([atributo, type])
        text = {lista[i]: lista[i+1] for i in range(0, len(lista), 2)}
        file.write(str(text) + os.linesep)
        file.close()
        self.create_shapefile(layer)

    def collect_ubx(self, layer: QgsVectorLayer, idActual: int, vertice: int = 1):
        if not os.path.exists(self.pathFolder):
            os.mkdir(self.pathFolder)
        plugin_dir = os.path.dirname(__file__)
        ruta = self.pathFolder + layer.name() + '/'
        if layer.geometryType() == QgsWkbTypes.PointGeometry:
            sentencia = "python3 {0}/collect_ubx.py colectar_punto {1} {2}.ubx {3}".format(str(plugin_dir), str(ruta),
                                                                         str(idActual), str(self.tiempoCaptura))
        else:
            sentencia = "python3 {0}/collect_ubx.py colectar_punto {1} {2}_{3}.ubx {4}".format(str(plugin_dir), str(ruta),
                                                                         str(idActual), str(vertice), str(self.tiempoCaptura))
        bash = os.system(sentencia)
        return bash

    def add_new_vertex(self):
        self.vertice = True
        self.locate()

    def create_shapefile(self, layer: QgsVectorLayer):
        nameNewLayer = str(self.pathProject) + '/Export/' + str(layer.name()) + ".shp"
        if not os.path.exists(nameNewLayer):
            newLayer = QgsVectorFileWriter.writeAsVectorFormat(layer, nameNewLayer, 'utf-8',
                                                     QgsCoordinateReferenceSystem('EPSG: 4326'), driverName="ESRI Shapefile")

    def cancell(self):
        self.tableVertices.clearContents()
        self.btnaddVertice.setEnabled(False)
        self.btnendGeometry.setEnabled(False)
        self.tableVertices.setEnabled(False)
        self.mMapLayerComboBox.setEnabled(True)
        self.btnubicarycentrar.setText("Ubicar y colectar")
        self.tableVertices.setRowCount(0)
        self.canvas.scene().removeItem(self.marker_polyline)
        self.canvas.scene().removeItem(self.marker_polygon)

    def closeEvent(self, event):
        if self.canvas is not None:
            self.canvas.scene().removeItem(self.marker)
        self.closingPlugin.emit()
        event.accept()
        self.openProject = True
        self.enableProject()